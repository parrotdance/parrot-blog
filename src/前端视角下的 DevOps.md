作为某前端项目（唯一的）技术负责人，最近开始参与 CI 流程的方案的讨论和具体配置工作。期间收到了一些表扬，但都带着“作为一个前端”这样的前提条件。我认为虽然顶着前端的名头，但技术本身是平等的，它不应该像切蛋糕一样被割裂到前端和后端。

这部分工作似乎有个更时髦的名字叫做「DevOps」。它更强调思想与方法论，而不是要求使用某种具体的技术或解决方案。

### CI 持续集成

我属于 MVVM 时代才加入前端圈子的新人。最初我还没有脚本的概念，但为了把写好的代码部署上线，我不得不人工重复地做一系列的事情：

1. 修改某些环境变量以适应要部署的线上环境。
2. 使用 Webpack （或其他打包工具）构建项目。
3. 将构建生成的文件夹压缩。
4. 自行将压缩包上传到服务器或者发给后端同事代劳。
5. 将服务器上的压缩包解压到 WebRoot 目录下。

这几乎是**最简单**的构建和部署需求了。但是作为程序员，这个流程操作几次后很快感到了厌烦。于是我开始学习 NodeJs 并编写了一段几十行的脚本来让计算机代我处理这些麻烦事，在确认脚本部署的程序正确运行的那一刻，我获得了巨大的成就感。

后来我知道了这件事情就是人们常说的 CI。

扩展一点来说，CI 的出现是为了**自动化构建与部署的过程并使其可监控**。它有很多种实现方式，可以是上文提到的一段简单的 NodeJs 脚本，可以使用 *Github Actions*，也可以使用 *Jenkins*。人们相信这个过程能够加速软件的开发和迭代效率，我对此深信不疑，因为一段脚本就为我节约了几分钟的发呆、学习、喝水时间，还不用担心因为操作失误带来的后果。我相信对于规模更大更复杂的项目它带来的正面影响只会越来越多。

### CD 持续交付 / 持续部署

“交付”和“部署”二者的概念对我来说相当接近。若是从开发的角度理解，当完成了“部署”的动作，让用户能够访问到线上的程序，此时便可以认为是完成“交付”了。

按传统的职责划分，这部分工作似乎都被划到了运维人员身上。那我接下来想说的 *Docker* 和 *K8S*，应该也是出自运维同学对自身工作流程的抽象。他们为了简化工作流程并提供高可用的服务，从 *JVM* 中获得灵感，开发出了 Docker。事实上，“从 *JVM* 中获得灵感”是我瞎猜的，仅仅是因为 Docker 底层实现也使用 JAVA 而已。

目前 Docker 和 K8S 已是业界普及度非常高的方案了，也许是因为他俩名声太大，使得我对其他类似方案并不很了解，但我相信业界一定也有过不少其他的实践。不同的技术栈带来的不同构建方式，来到 Docker 面前都变得众生平等，都被称作「镜像」。Docker 的意义在于它能够（像 JVM 一样）屏蔽底层操作系统的差异，对上层应用提供一致的接口，使构建产物（镜像）也能像 JAVA 代码一样，一次编写多处运行。配合 K8S 提供的管理镜像的能力，开发、测试、上线的流程也变成了镜像在对应环境的流转过程。就像 MVVM 之于 MVC 一样，以镜像为单位的部署流程极大地降低了运维人员的心智负担。

### CI / CD 不分家

实际工作中对 CI / CD 流程的讨论更多的是对实现方案**成本**的考量。例如我所在的项目组主要由后端主导，考虑到离线部署的情况、前端技术栈的多变以及运维成本最终决定在开发期执行构建，将构建产物一同提交到仓库，CI 过程只负责拉取文件构建镜像，而不是在 CI 过程中完成这些事情。这个方案并不优雅，但在多方面考虑后最终还是作出了决定。

无论是 CI 还是 CD，其核心理念都在于“持续”二字，换种说法就是“自动化”。其实我一开始想要从文章结构上划清二者的界限，但目前看来收效甚微。网络上对于 CI / CD 的叙述也多是混为一谈，或许这就像我在文章开头对技术的理解一样，它们代表的思想本就是一个整体。

写到这里我开始觉得，在前端这个位置上对「DevOps」的理解其实相当有限，只领悟到了皮毛。或者说是因为平台和项目的关系，没能有很多机会参与这些工作的规划和设计，就很难进一步体会这些技术或者思想对工程的意义。

Whatever，祝我好运。
