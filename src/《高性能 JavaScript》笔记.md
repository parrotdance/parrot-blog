> 这本书年代略微有些久远，书中提到的许多问题现今都有了良好的解决方案。但许多语言层面和优化策略相关的内容依然具有相当的参考价值。

- 脚本会阻塞页面渲染，因此需要合理组织脚本位置和执行策略
- 原型链/作用域链
    - 原型链模型导致访问深层对象的属性会产生更大的性能损耗
    - 嵌套作用域的存在导致访问外层作用域的变量会产生更大的性能损耗
    - 通过使用局部变量缓存数据来优化
- 字符串是 JavaScript 中最慢的部分之一，根据不同浏览器的内存实现方式不同，不同的拼接操作会产生不一样的运行时效率，这点通常在编译期会有优化
- **DOM 与 JS 引擎相互独立，并且不同浏览器实现有差别，他们之间通信是需要相当成本的**
- `HTMLCollection` 是实时(动态)的，如果不需要保持对某集合元素的监控，尽可能使用返回 `NodeList` (静态) 的 `querySelectorAll` 来获取集合 这样速度更快并且能够避免访问动态集合带来的性能和潜在逻辑问题
- 重排涉及到渲染树大量节点的重建，尽可能避免触发重排
    - 添加，删除，改变位置，尺寸，内容(文本换行)，resize 都会触发重排
    - 不在文档流中的元素是不会触发重排的
    - 需要调整多个元素属性时可以先令元素脱离文档流，修改后再回归文档流
    - 重排伴随着繁琐的计算过程，因此在大多数浏览器中都通过缓存修改队列和批量执行来减少重构渲染树的次数
    - 执行一些获取布局信息的动作(例如获取 `scrollHeight` 或调用 `getComputedStyle()`) 会使得缓存的队列立即执行，因为这些属性或方法总是需要返回最新的布局信息
- 各种循环方式效率差不太多，只有 `for…in` 明显较慢
- 数组的各种遍历方法比语言本身的循环要慢一些，影响主要来自额外的函数调用栈
- `switch` 通常比 `if-else` 快，但不会快很多，应该优先考虑可读性，即多分支情况下使用 `switch`
- 对于大量分支的情况，查找表方式(通过索引访问数组或对象)会比 `switch` 和 `if-else` 都快
- 递归实现起来可能比循环更加简洁且简单，但是有严格的调用栈限制 在输入数据规模难以预测或终止条件不明时使用循环是更稳妥的选择
- **再重要的代码其重要性也比不上及时反馈用户操作和流畅的页面动画**
- 使用定时器分批处理大量计算可以减少对 UI 线程的阻塞，但会消耗更多时间
- 浏览器环境下，更理想的非阻塞计算方案是使用 Web Worker，它在一个完全独立的线程中运行，并且通过 `postMessage()` 和 `message` 事件与主线程通信
- JavaScript 中速度很快的部分
    - 各种位运算
    - 内置的原生方法和变量，如 `Math` 对象
- `Object` 和 `Array` 类型的字面量赋值会比索引赋值效率更高
- `eval()`，`Function()` 构造函数，`setTimeout()`，`setInterval()` 都是可以传入动态字符串并尝试作为代码执行的，但是会带来“双重求值”的影响
    - “双重求值”指的是先以正常的方式求值，在执行过程中对包含在字符串中的代码发起另一个求值运算
    - 这与执行同样的一段代码相比，代价非常之高
